/*********************************************************************************************************
* 模块名称：PackUnpack.c
* 摘    要：PackUnpack模块
* 当前版本：1.0.0
* 作    者：SZLY(COPYRIGHT 2018 - 2020 SZLY. All rights reserved.)
* 完成日期：2020年01月01日
* 内    容：
*           （1）数据包格式：模块ID+数据头+二级ID+数据1...数据6+校验和
*                            数据包都有校验和，由1个字节模块ID、1个字节数据头，1个字节二级ID，6个字节数据
*                            和1个字节校验和构成，因此，数据包长度为10个字节，数据包的数据容量为6个
*           （2）模块ID的最高位BIT7为0，数据头、二级ID、数据以及校验和的最高位为1，所有包的数据头依次包含
*                数据字节的最高位，如数据头的BIT0为二级ID的BIT7，数据头的BIT1为数据1的BIT7，数据头的BIT2
*                为数据2的BIT7，数据头的BIT6为数据6的BIT7
*           （3）参数板协议的简易版
* 注    意：                                                                  
**********************************************************************************************************
* 取代版本：
* 作    者：
* 完成日期：
* 修改内容： 
* 修改文件： 
*********************************************************************************************************/

/*********************************************************************************************************
*                                              包含头文件
*********************************************************************************************************/
#include "PackUnpack.h"
#include  "Timer.h"
#include "SendDataToHost.h"
#include "string.h"
#include "Main.h"

/*********************************************************************************************************
*                                              宏定义
*********************************************************************************************************/

/*********************************************************************************************************
*                                              内部变量
*********************************************************************************************************/
//以下5个参数在打包和解包的时候使用
static StructPackType s_ptPack;

static uint8       s_iPackLen;       //数据包长度，用来判断数据长度是否为10，不为10为错误包
static uint8       s_iGotPackId;     //获取到ID的标志
static uint8       s_iRestByteNum;   //剩余字节数
static uint32      s_millis_last;    //上次接收到串口1的数据的时间

/*********************************************************************************************************
*                                              内部函数声明
*********************************************************************************************************/
static  void  PackWithCheckSum(uint8* pPack);    //带校验和的数据打包
static  short  CalculatePackCheckSum(StructPackType* pPack);    //计算校验和
static  uint8    UnpackWithCheckSum(StructPackType* pPack); //带校验和的数据解包

/*********************************************************************************************************
*                                              内部函数实现
*********************************************************************************************************/

/*********************************************************************************************************
* 函数名称：PackWithCheckSum
* 函数功能：带校验和的数据打包
* 输入参数：待打包的数据pPack的首地址 
* 输出参数：打包好的数据pPack的首地址
* 返 回 值：void
* 创建日期：2021年07月11日
* 注    意：
*********************************************************************************************************/
static void PackWithCheckSum(uint8* pPack)
{

}

/*********************************************************************************************************
* 函数名称：CalculatePackCheckSum
* 函数功能：计算数据包校验和，2字节
* 输入参数：待打包的数据pPack的首地址 
* 输出参数：无
* 返 回 值：校验和，2字节
* 创建日期：2022年2月19日15:28:02
* 注    意：
*********************************************************************************************************/
static short CalculatePackCheckSum(StructPackType* pPack)
{
  register int nleft = DATALEN;
  register int sum   = 0;
  register short *w  = (short *)pPack->arrData;
  short answer       = 0;
 
  while(nleft>1)
  {
    sum+=*w++;
    nleft-=2;
  }
  if(nleft==1)
  {
    *(unsigned char *)(&answer)=*(unsigned char *)w;
    sum+=answer;
  }
 
  //sum=(sum>>16)+(sum&0xffff);
  //sum+=(sum>>16);
  answer=~sum;
  
  return answer;
}

/*********************************************************************************************************
* 函数名称：UnpackWithCheckSum
* 函数功能：带校验和的数据解包 
* 输入参数：待解包的数据pPack的首地址，打包后的数据长度  
* 输出参数：解包好的数据pPack的首地址
* 返 回 值：0-解包不成功，1-解包成功
* 创建日期：2022年02月01日
* 注    意：
*********************************************************************************************************/
static uint8  UnpackWithCheckSum(StructPackType* pPack)
{
  #if 1
  if(pPack->checkSum == CalculatePackCheckSum(pPack))//校验和一致
  {
    return 1;
  }
  return 0;
  #else
  return 1;
  #endif
}

/*********************************************************************************************************
*                                              API函数实现
*********************************************************************************************************/

/*********************************************************************************************************
* 函数名称：InitPackUnpack
* 函数功能：初始化PackUnpack模块，其余参数均默认为0 
* 输入参数：void
* 输出参数：void
* 返 回 值：void
* 创建日期：2022年02月02日
* 注    意：
*********************************************************************************************************/
void  InitPackUnpack(void)
{
  memset(&s_ptPack, 0, sizeof(StructPackType));//s_ptPack默认为0
  
  s_iPackLen     = 0; //数据包的长度默认为0
  s_iGotPackId   = 0; //获取到数据包ID标志默认为0，即尚未获取到有效模块ID
  s_iRestByteNum = 0; //剩余的字节数默认为0 
  s_millis_last  = 0;//上次接收到串口1的数据的时间
}

/*********************************************************************************************************
* 函数名称：PackData
* 函数功能：对数据进行打包
* 输入参数：pPT，待打包的数据首地址
* 输出参数：pPT，打包好的数据首地址
* 返 回 值：valid，1-打包成功，0-打包失败
* 创建日期：2022年01月28日
* 注    意：
*********************************************************************************************************/
uint8  PackData(StructPackType* pPT)
{
  uint8 valid = 0;

  if(pPT->packType == TYPE_DATA || pPT->packType == TYPE_ROUTE || pPT->packType == TYPE_SYS)//包种类必须在0x01～0x03之间
  {
    valid = 1;    //表示模块ID是合法的
    pPT->checkSum = CalculatePackCheckSum(pPT);//计算校验和
  }

  return(valid);
}

/*********************************************************************************************************
* 函数名称：UnPackData
* 函数功能：对数据进行解包，返回1表示解析到一个有效包，此时通过调用GetUnPackRslt函数将数据包取走，否则新数
*           据会覆盖解析好的数据包 
* 输入参数：data，待解包的数据
* 输出参数：void
* 返 回 值：是否解包成功，1-解包成功，0-解包失败
* 创建日期：2022年02月01日
* 注    意：
*********************************************************************************************************/
uint8  UnPackData(uint8 data)
{
  uint8 findPack = 0;
  uint8* pBuf;
  uint32 millis_cur = millis();//当前时间（相对时间）
  
  pBuf = s_ptPack.arrData;      //pBuf指向s_ptPack的缓冲区arrData，即pBuf和s_ptPack->arrData的值是同一个
  if(s_iGotPackId)            //已经接收到包ID
  {
    if(millis_cur - s_millis_last < 50)//时间间隔不超过xms
    {
      pBuf[s_iPackLen - 1] = data;             //赋给pBuf[s_iPackLen]，也相当于赋给s_ptPack中对应的成员
      s_iPackLen++;                            //包长自增
      s_iRestByteNum--;                        //剩余字节数自减
      if (0 >= s_iRestByteNum && PACKLEN == s_iPackLen)//数据包接收完成
      {
        findPack = UnpackWithCheckSum(&s_ptPack);  //接收到完整数据包后尝试解包
        s_iGotPackId = 0;                      //清除获取到包ID标志，即重新判断下一个数据包
        
        #if (defined SINK) && (SINK == TRUE)//汇聚节点
        if( s_ptPack.packType != 0x02 && findPack == 0)//   s_ptPack.packType != 0x02 &&
        {
          debug((uint8*)&s_ptPack);
          
        }
        #endif
        
      }
    }
    else//超时，认为是新数据包
    {
      debug("超时");
      if( data == TYPE_DATA || data == TYPE_ROUTE  || data == TYPE_SYS)
      {
        s_iRestByteNum     = PACKLEN - 1;//剩余的包长，即打包好的包长减去1
        s_iPackLen         = 1;          //尚未接收到包ID即表示包长为1
        s_ptPack.packType = data;       //数据包的种类
        s_iGotPackId       = 1;          //表示已经接收到包ID 
      }
    }
  }
  else if(data == TYPE_DATA || data == TYPE_ROUTE  || data == TYPE_SYS)       //当前的数据为包ID,即接收到包头开始接收，否则丢弃
  {
    s_iRestByteNum     = PACKLEN - 1;//剩余的包长，即打包好的包长减去1
    s_iPackLen         = 1;          //尚未接收到包ID即表示包长为1
    s_ptPack.packType = data;       //数据包的种类
    s_iGotPackId       = 1;          //表示已经接收到包ID  
  }
  s_millis_last  = millis();         //更新这次接收到串口1的数据的时间，供下次使用
  return findPack;                   //如果获取到完整的数据包，并解包成功，findPack为1，否则为0
}

/*********************************************************************************************************
* 函数名称：GetUnPackRslt
* 函数功能：获取解包结果
* 输入参数：void 
* 输出参数：void
* 返 回 值：解包后的结果
* 创建日期：2022年02月01日
* 注    意：
*********************************************************************************************************/
StructPackType  GetUnPackRslt(void)
{
  return(s_ptPack);
}
